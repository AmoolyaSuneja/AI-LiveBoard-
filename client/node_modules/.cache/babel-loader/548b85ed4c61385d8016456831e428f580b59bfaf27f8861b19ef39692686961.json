{"ast":null,"code":"export function recognizeShape(points) {\n  // Early return for insufficient points\n  if (!points || points.length < 15) return null;\n\n  // Calculate bounding box with safety checks\n  const xs = points.map(p => p[0] || 0);\n  const ys = points.map(p => p[1] || 0);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  // Debugging logs (remove in production)\n  console.log(`Shape detection started for ${points.length} points`);\n  console.log(`Bounding box: ${width}x${height}`);\n\n  // Circle detection with improved logic\n  const circleConfidence = detectCircle(points, width, height);\n  if (circleConfidence > 0.7) {\n    const {\n      center,\n      radius\n    } = calculateCircle(points);\n    console.log(`Circle detected (confidence: ${circleConfidence.toFixed(2)})`);\n    return {\n      type: 'circle',\n      x: center.x - radius,\n      y: center.y - radius,\n      radius: radius\n    };\n  }\n\n  // Rectangle detection with improved logic\n  const rectangleConfidence = detectRectangle(points);\n  if (rectangleConfidence > 0.6) {\n    console.log(`Rectangle detected (confidence: ${rectangleConfidence.toFixed(2)})`);\n    return {\n      type: 'rectangle',\n      x: minX,\n      y: minY,\n      width,\n      height\n    };\n  }\n  console.log(\"No recognized shape detected\");\n  return null;\n}\n\n// Helper functions\nfunction detectCircle(points, width, height) {\n  const {\n    center,\n    radius,\n    variance\n  } = calculateCircle(points);\n\n  // Aspect ratio check (circle should be roughly square)\n  const aspectRatio = Math.abs(width - height) / Math.max(width, height);\n\n  // Combine multiple factors for confidence score\n  const sizeConsistency = 1 - variance / (radius * 2);\n  const aspectScore = 1 - Math.min(aspectRatio, 0.3);\n  return sizeConsistency * 0.7 + aspectScore * 0.3;\n}\nfunction calculateCircle(points) {\n  const centroid = [points.reduce((sum, p) => sum + p[0], 0) / points.length, points.reduce((sum, p) => sum + p[1], 0) / points.length];\n  const distances = points.map(p => Math.hypot(p[0] - centroid[0], p[1] - centroid[1]));\n  const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;\n  const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;\n  return {\n    center: {\n      x: centroid[0],\n      y: centroid[1]\n    },\n    radius: avgDistance,\n    variance: variance\n  };\n}\nfunction detectRectangle(points) {\n  const angleThreshold = 0.25; // Slightly more tolerant angle threshold\n  let rightAngles = 0;\n  let straightLines = 0;\n  for (let i = 2; i < points.length - 2; i++) {\n    const v1 = [points[i][0] - points[i - 2][0], points[i][1] - points[i - 2][1]];\n    const v2 = [points[i + 2][0] - points[i][0], points[i + 2][1] - points[i][1]];\n    const angle = Math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / (Math.hypot(...v1) * Math.hypot(...v2)));\n    if (Math.abs(angle - Math.PI / 2) < angleThreshold) {\n      rightAngles++;\n    } else if (angle < angleThreshold) {\n      straightLines++;\n    }\n  }\n\n  // Normalize based on point count\n  const normalizedAngles = rightAngles / (points.length / 4);\n  const normalizedLines = straightLines / (points.length / 2);\n  return normalizedAngles * 0.6 + normalizedLines * 0.4;\n}","map":{"version":3,"names":["recognizeShape","points","length","xs","map","p","ys","minX","Math","min","maxX","max","minY","maxY","width","height","console","log","circleConfidence","detectCircle","center","radius","calculateCircle","toFixed","type","x","y","rectangleConfidence","detectRectangle","variance","aspectRatio","abs","sizeConsistency","aspectScore","centroid","reduce","sum","distances","hypot","avgDistance","d","pow","angleThreshold","rightAngles","straightLines","i","v1","v2","angle","acos","PI","normalizedAngles","normalizedLines"],"sources":["C:/Users/Amoolya Suneja/Desktop/AI-Liveboard/client/src/utils/shapeRecognition.js"],"sourcesContent":["export function recognizeShape(points) {\r\n  // Early return for insufficient points\r\n  if (!points || points.length < 15) return null;\r\n  \r\n  // Calculate bounding box with safety checks\r\n  const xs = points.map(p => p[0] || 0);\r\n  const ys = points.map(p => p[1] || 0);\r\n  const minX = Math.min(...xs);\r\n  const maxX = Math.max(...xs);\r\n  const minY = Math.min(...ys);\r\n  const maxY = Math.max(...ys);\r\n  const width = maxX - minX;\r\n  const height = maxY - minY;\r\n\r\n  // Debugging logs (remove in production)\r\n  console.log(`Shape detection started for ${points.length} points`);\r\n  console.log(`Bounding box: ${width}x${height}`);\r\n\r\n  // Circle detection with improved logic\r\n  const circleConfidence = detectCircle(points, width, height);\r\n  if (circleConfidence > 0.7) {\r\n    const { center, radius } = calculateCircle(points);\r\n    console.log(`Circle detected (confidence: ${circleConfidence.toFixed(2)})`);\r\n    return {\r\n      type: 'circle',\r\n      x: center.x - radius,\r\n      y: center.y - radius,\r\n      radius: radius\r\n    };\r\n  }\r\n\r\n  // Rectangle detection with improved logic\r\n  const rectangleConfidence = detectRectangle(points);\r\n  if (rectangleConfidence > 0.6) {\r\n    console.log(`Rectangle detected (confidence: ${rectangleConfidence.toFixed(2)})`);\r\n    return {\r\n      type: 'rectangle',\r\n      x: minX,\r\n      y: minY,\r\n      width,\r\n      height\r\n    };\r\n  }\r\n\r\n  console.log(\"No recognized shape detected\");\r\n  return null;\r\n}\r\n\r\n// Helper functions\r\nfunction detectCircle(points, width, height) {\r\n  const { center, radius, variance } = calculateCircle(points);\r\n  \r\n  // Aspect ratio check (circle should be roughly square)\r\n  const aspectRatio = Math.abs(width - height) / Math.max(width, height);\r\n  \r\n  // Combine multiple factors for confidence score\r\n  const sizeConsistency = 1 - (variance / (radius * 2));\r\n  const aspectScore = 1 - Math.min(aspectRatio, 0.3);\r\n  \r\n  return (sizeConsistency * 0.7 + aspectScore * 0.3);\r\n}\r\n\r\nfunction calculateCircle(points) {\r\n  const centroid = [\r\n    points.reduce((sum, p) => sum + p[0], 0) / points.length,\r\n    points.reduce((sum, p) => sum + p[1], 0) / points.length\r\n  ];\r\n  \r\n  const distances = points.map(p => \r\n    Math.hypot(p[0] - centroid[0], p[1] - centroid[1])\r\n  );\r\n  \r\n  const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;\r\n  const variance = distances.reduce((sum, d) => \r\n    sum + Math.pow(d - avgDistance, 2), 0) / distances.length;\r\n\r\n  return {\r\n    center: { x: centroid[0], y: centroid[1] },\r\n    radius: avgDistance,\r\n    variance: variance\r\n  };\r\n}\r\n\r\nfunction detectRectangle(points) {\r\n  const angleThreshold = 0.25; // Slightly more tolerant angle threshold\r\n  let rightAngles = 0;\r\n  let straightLines = 0;\r\n\r\n  for (let i = 2; i < points.length - 2; i++) {\r\n    const v1 = [points[i][0] - points[i-2][0], points[i][1] - points[i-2][1]];\r\n    const v2 = [points[i+2][0] - points[i][0], points[i+2][1] - points[i][1]];\r\n    \r\n    const angle = Math.acos(\r\n      (v1[0]*v2[0] + v1[1]*v2[1]) / \r\n      (Math.hypot(...v1) * Math.hypot(...v2))\r\n    );\r\n\r\n    if (Math.abs(angle - Math.PI/2) < angleThreshold) {\r\n      rightAngles++;\r\n    } else if (angle < angleThreshold) {\r\n      straightLines++;\r\n    }\r\n  }\r\n\r\n  // Normalize based on point count\r\n  const normalizedAngles = rightAngles / (points.length / 4);\r\n  const normalizedLines = straightLines / (points.length / 2);\r\n  \r\n  return (normalizedAngles * 0.6 + normalizedLines * 0.4);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}