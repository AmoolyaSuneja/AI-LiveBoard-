{"ast":null,"code":"export function recognizeShape(points) {\n  if (points.length < 10) return null;\n\n  // Calculate bounding box\n  const xs = points.map(p => p[0]);\n  const ys = points.map(p => p[1]);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  // Circle detection\n  const centroid = [points.reduce((sum, p) => sum + p[0], 0) / points.length, points.reduce((sum, p) => sum + p[1], 0) / points.length];\n  const distances = points.map(p => Math.sqrt(Math.pow(p[0] - centroid[0], 2) + Math.pow(p[1] - centroid[1], 2)));\n  const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;\n  const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;\n  if (variance < 500 && Math.abs(width - height) < 30) {\n    return {\n      type: 'circle',\n      x: centroid[0] - avgDistance,\n      y: centroid[1] - avgDistance,\n      radius: avgDistance\n    };\n  }\n\n  // Rectangle detection\n  const angleThreshold = 0.2;\n  let rightAngles = 0;\n  for (let i = 2; i < points.length - 2; i++) {\n    const v1 = [points[i][0] - points[i - 2][0], points[i][1] - points[i - 2][1]];\n    const v2 = [points[i + 2][0] - points[i][0], points[i + 2][1] - points[i][1]];\n    const dot = v1[0] * v2[0] + v1[1] * v2[1];\n    const mag1 = Math.sqrt(v1[0] ** 2 + v1[1] ** 2);\n    const mag2 = Math.sqrt(v2[0] ** 2 + v2[1] ** 2);\n    if (mag1 > 5 && mag2 > 5) {\n      const angle = Math.acos(dot / (mag1 * mag2));\n      if (Math.abs(angle - Math.PI / 2) < angleThreshold) rightAngles++;\n    }\n  }\n  if (rightAngles > 3) {\n    return {\n      type: 'rectangle',\n      x: minX,\n      y: minY,\n      width,\n      height\n    };\n  }\n  return null;\n}","map":{"version":3,"names":["recognizeShape","points","length","xs","map","p","ys","minX","Math","min","maxX","max","minY","maxY","width","height","centroid","reduce","sum","distances","sqrt","pow","avgDistance","d","variance","abs","type","x","y","radius","angleThreshold","rightAngles","i","v1","v2","dot","mag1","mag2","angle","acos","PI"],"sources":["C:/Users/Amoolya Suneja/Desktop/AI-Liveboard/client/src/utils/shapeRecognition.js"],"sourcesContent":["export function recognizeShape(points) {\r\n  if (points.length < 10) return null;\r\n  \r\n  // Calculate bounding box\r\n  const xs = points.map(p => p[0]);\r\n  const ys = points.map(p => p[1]);\r\n  const minX = Math.min(...xs);\r\n  const maxX = Math.max(...xs);\r\n  const minY = Math.min(...ys);\r\n  const maxY = Math.max(...ys);\r\n  const width = maxX - minX;\r\n  const height = maxY - minY;\r\n  \r\n  // Circle detection\r\n  const centroid = [\r\n    points.reduce((sum, p) => sum + p[0], 0) / points.length,\r\n    points.reduce((sum, p) => sum + p[1], 0) / points.length\r\n  ];\r\n  \r\n  const distances = points.map(p => \r\n    Math.sqrt(Math.pow(p[0] - centroid[0], 2) + Math.pow(p[1] - centroid[1], 2))\r\n  );\r\n  const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;\r\n  const variance = distances.reduce((sum, d) => \r\n    sum + Math.pow(d - avgDistance, 2), 0) / distances.length;\r\n\r\n  if (variance < 500 && Math.abs(width - height) < 30) {\r\n    return {\r\n      type: 'circle',\r\n      x: centroid[0] - avgDistance,\r\n      y: centroid[1] - avgDistance,\r\n      radius: avgDistance\r\n    };\r\n  }\r\n\r\n  // Rectangle detection\r\n  const angleThreshold = 0.2;\r\n  let rightAngles = 0;\r\n  \r\n  for (let i = 2; i < points.length - 2; i++) {\r\n    const v1 = [points[i][0] - points[i-2][0], points[i][1] - points[i-2][1]];\r\n    const v2 = [points[i+2][0] - points[i][0], points[i+2][1] - points[i][1]];\r\n    const dot = v1[0]*v2[0] + v1[1]*v2[1];\r\n    const mag1 = Math.sqrt(v1[0]**2 + v1[1]**2);\r\n    const mag2 = Math.sqrt(v2[0]**2 + v2[1]**2);\r\n    \r\n    if (mag1 > 5 && mag2 > 5) {\r\n      const angle = Math.acos(dot / (mag1 * mag2));\r\n      if (Math.abs(angle - Math.PI/2) < angleThreshold) rightAngles++;\r\n    }\r\n  }\r\n  \r\n  if (rightAngles > 3) {\r\n    return {\r\n      type: 'rectangle',\r\n      x: minX,\r\n      y: minY,\r\n      width,\r\n      height\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}