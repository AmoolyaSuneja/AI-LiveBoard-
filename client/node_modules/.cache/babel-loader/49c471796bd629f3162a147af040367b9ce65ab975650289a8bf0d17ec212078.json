{"ast":null,"code":"export function recognizeShape(points) {\n  if (!points || points.length < 5) return null;\n\n  // Calculate bounding box\n  const xs = points.map(p => p[0]);\n  const ys = points.map(p => p[1]);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const width = maxX - minX;\n  const height = maxY - minY;\n  const centerX = (minX + maxX) / 2;\n  const centerY = (minY + maxY) / 2;\n\n  // Calculate total line length\n  let totalLength = 0;\n  for (let i = 1; i < points.length; i++) {\n    const dx = points[i][0] - points[i - 1][0];\n    const dy = points[i][1] - points[i - 1][1];\n    totalLength += Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // Circle detection - simpler method\n  const circleScore = detectCircle(points, centerX, centerY, width, height, totalLength);\n  if (circleScore > 0.7) {\n    return {\n      type: 'circle',\n      x: centerX - width / 2,\n      y: centerY - height / 2,\n      radius: Math.min(width, height) / 2\n    };\n  }\n\n  // Rectangle detection - simpler method\n  const rectScore = detectRectangle(points, width, height, totalLength);\n  if (rectScore > 0.7) {\n    return {\n      type: 'rectangle',\n      x: minX,\n      y: minY,\n      width,\n      height\n    };\n  }\n  return null;\n}\nfunction detectCircle(points, centerX, centerY, width, height, totalLength) {\n  // 1. Check if start and end points are close\n  const start = points[0];\n  const end = points[points.length - 1];\n  const startEndDistance = Math.hypot(start[0] - end[0], start[1] - end[1]);\n\n  // 2. Check if aspect ratio is near 1\n  const aspectRatio = Math.abs(width - height) / Math.max(width, height);\n\n  // 3. Check if path length is close to circumference\n  const expectedCircumference = 2 * Math.PI * Math.min(width, height) / 2;\n  const lengthRatio = Math.min(totalLength / expectedCircumference, expectedCircumference / totalLength);\n  return (startEndDistance < 20 ? 0.4 : 0) + (aspectRatio < 0.3 ? 0.3 : 0) + (lengthRatio > 0.7 ? 0.3 : 0);\n}\nfunction detectRectangle(points, width, height, totalLength) {\n  // 1. Check if start and end points are close\n  const start = points[0];\n  const end = points[points.length - 1];\n  const startEndDistance = Math.hypot(start[0] - end[0], start[1] - end[1]);\n\n  // 2. Check for straight lines in the drawing\n  let straightLineSegments = 0;\n  for (let i = 2; i < points.length - 2; i++) {\n    const dx1 = points[i][0] - points[i - 1][0];\n    const dy1 = points[i][1] - points[i - 1][1];\n    const dx2 = points[i + 1][0] - points[i][0];\n    const dy2 = points[i + 1][1] - points[i][1];\n\n    // Check if direction is similar\n    const dot = dx1 * dx2 + dy1 * dy2;\n    if (dot > 0.9 * Math.hypot(dx1, dy1) * Math.hypot(dx2, dy2)) {\n      straightLineSegments++;\n    }\n  }\n\n  // 3. Check if path length is close to perimeter\n  const expectedPerimeter = 2 * (width + height);\n  const lengthRatio = Math.min(totalLength / expectedPerimeter, expectedPerimeter / totalLength);\n  return (startEndDistance < 20 ? 0.4 : 0) + (straightLineSegments > 3 ? 0.3 : 0) + (lengthRatio > 0.7 ? 0.3 : 0);\n}","map":{"version":3,"names":["recognizeShape","points","length","xs","map","p","ys","minX","Math","min","maxX","max","minY","maxY","width","height","centerX","centerY","totalLength","i","dx","dy","sqrt","circleScore","detectCircle","type","x","y","radius","rectScore","detectRectangle","start","end","startEndDistance","hypot","aspectRatio","abs","expectedCircumference","PI","lengthRatio","straightLineSegments","dx1","dy1","dx2","dy2","dot","expectedPerimeter"],"sources":["C:/Users/Amoolya Suneja/Desktop/AI-Liveboard/client/src/utils/shapeRecognition.js"],"sourcesContent":["export function recognizeShape(points) {\r\n  if (!points || points.length < 5) return null;\r\n  \r\n  // Calculate bounding box\r\n  const xs = points.map(p => p[0]);\r\n  const ys = points.map(p => p[1]);\r\n  const minX = Math.min(...xs);\r\n  const maxX = Math.max(...xs);\r\n  const minY = Math.min(...ys);\r\n  const maxY = Math.max(...ys);\r\n  const width = maxX - minX;\r\n  const height = maxY - minY;\r\n  const centerX = (minX + maxX) / 2;\r\n  const centerY = (minY + maxY) / 2;\r\n  \r\n  // Calculate total line length\r\n  let totalLength = 0;\r\n  for (let i = 1; i < points.length; i++) {\r\n    const dx = points[i][0] - points[i-1][0];\r\n    const dy = points[i][1] - points[i-1][1];\r\n    totalLength += Math.sqrt(dx*dx + dy*dy);\r\n  }\r\n  \r\n  // Circle detection - simpler method\r\n  const circleScore = detectCircle(points, centerX, centerY, width, height, totalLength);\r\n  if (circleScore > 0.7) {\r\n    return {\r\n      type: 'circle',\r\n      x: centerX - width/2,\r\n      y: centerY - height/2,\r\n      radius: Math.min(width, height)/2\r\n    };\r\n  }\r\n  \r\n  // Rectangle detection - simpler method\r\n  const rectScore = detectRectangle(points, width, height, totalLength);\r\n  if (rectScore > 0.7) {\r\n    return {\r\n      type: 'rectangle',\r\n      x: minX,\r\n      y: minY,\r\n      width,\r\n      height\r\n    };\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction detectCircle(points, centerX, centerY, width, height, totalLength) {\r\n  // 1. Check if start and end points are close\r\n  const start = points[0];\r\n  const end = points[points.length-1];\r\n  const startEndDistance = Math.hypot(start[0]-end[0], start[1]-end[1]);\r\n  \r\n  // 2. Check if aspect ratio is near 1\r\n  const aspectRatio = Math.abs(width - height) / Math.max(width, height);\r\n  \r\n  // 3. Check if path length is close to circumference\r\n  const expectedCircumference = 2 * Math.PI * Math.min(width, height)/2;\r\n  const lengthRatio = Math.min(totalLength/expectedCircumference, expectedCircumference/totalLength);\r\n  \r\n  return (startEndDistance < 20 ? 0.4 : 0) + \r\n         (aspectRatio < 0.3 ? 0.3 : 0) + \r\n         (lengthRatio > 0.7 ? 0.3 : 0);\r\n}\r\n\r\nfunction detectRectangle(points, width, height, totalLength) {\r\n  // 1. Check if start and end points are close\r\n  const start = points[0];\r\n  const end = points[points.length-1];\r\n  const startEndDistance = Math.hypot(start[0]-end[0], start[1]-end[1]);\r\n  \r\n  // 2. Check for straight lines in the drawing\r\n  let straightLineSegments = 0;\r\n  for (let i = 2; i < points.length-2; i++) {\r\n    const dx1 = points[i][0] - points[i-1][0];\r\n    const dy1 = points[i][1] - points[i-1][1];\r\n    const dx2 = points[i+1][0] - points[i][0];\r\n    const dy2 = points[i+1][1] - points[i][1];\r\n    \r\n    // Check if direction is similar\r\n    const dot = dx1*dx2 + dy1*dy2;\r\n    if (dot > 0.9 * Math.hypot(dx1, dy1) * Math.hypot(dx2, dy2)) {\r\n      straightLineSegments++;\r\n    }\r\n  }\r\n  \r\n  // 3. Check if path length is close to perimeter\r\n  const expectedPerimeter = 2 * (width + height);\r\n  const lengthRatio = Math.min(totalLength/expectedPerimeter, expectedPerimeter/totalLength);\r\n  \r\n  return (startEndDistance < 20 ? 0.4 : 0) + \r\n         (straightLineSegments > 3 ? 0.3 : 0) + \r\n         (lengthRatio > 0.7 ? 0.3 : 0);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}