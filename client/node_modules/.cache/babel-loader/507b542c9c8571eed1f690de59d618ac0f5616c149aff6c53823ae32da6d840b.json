{"ast":null,"code":"import { SHAPES } from './constants';\nexport function recognizeShape(points) {\n  if (!points || points.length < 6) return null;\n\n  // Calculate bounding box\n  const xs = points.map(p => p[0]);\n  const ys = points.map(p => p[1]);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const width = maxX - minX;\n  const height = maxY - minY;\n  const centerX = (minX + maxX) / 2;\n  const centerY = (minY + maxY) / 2;\n\n  // Skip very small shapes\n  if (width < 20 || height < 20) return null;\n\n  // Calculate path length\n  let pathLength = 0;\n  for (let i = 1; i < points.length; i++) {\n    pathLength += Math.hypot(points[i][0] - points[i - 1][0], points[i][1] - points[i - 1][1]);\n  }\n\n  // Calculate shape closure\n  const startEndDist = Math.hypot(points[0][0] - points[points.length - 1][0], points[0][1] - points[points.length - 1][1]);\n  const isClosedShape = startEndDist < Math.min(width, height) * 0.6;\n\n  // Multiple detection methods\n  const lineScore = detectLine(points, width, height, pathLength);\n  const circleScore = detectCircle(points, centerX, centerY, width, height, pathLength);\n  const rectScore = detectRectangle(points, width, height, pathLength);\n  console.log('Shape Analysis:', {\n    points: points.length,\n    width,\n    height,\n    aspectRatio: Math.min(width, height) / Math.max(width, height),\n    startEndDist,\n    isClosedShape,\n    lineScore,\n    circleScore,\n    rectScore,\n    thresholds: {\n      line: lineThreshold,\n      circle: circleThreshold,\n      rect: rectThreshold,\n      margin\n    }\n  });\n\n  // Improved decision logic with more lenient thresholds\n  const lineThreshold = 0.6; // Lowered from 0.8\n  const circleThreshold = 0.5; // Lowered from 0.7\n  const rectThreshold = 0.5; // Lowered from 0.6\n  const margin = 0.1; // Reduced from 0.2\n\n  // Check for line first (highest priority)\n  if (lineScore > lineThreshold && lineScore > Math.max(circleScore, rectScore) + margin) {\n    return {\n      type: SHAPES.LINE,\n      x: minX,\n      y: minY,\n      x2: maxX,\n      y2: maxY,\n      width: width,\n      height: height\n    };\n  }\n\n  // Check for circle/oval\n  if (circleScore > circleThreshold && circleScore > rectScore + margin) {\n    const radius = Math.min(width, height) / 2;\n    return {\n      type: SHAPES.CIRCLE,\n      x: centerX - radius,\n      y: centerY - radius,\n      radius: radius\n    };\n  }\n\n  // Check for rectangle/square\n  if (rectScore > rectThreshold && rectScore > circleScore + margin) {\n    return {\n      type: SHAPES.RECTANGLE,\n      x: minX,\n      y: minY,\n      width: width,\n      height: height\n    };\n  }\n  return null;\n}\nfunction detectCircle(points, centerX, centerY, width, height, pathLength) {\n  // Method 1: Distance from center consistency\n  let totalDist = 0;\n  let distances = [];\n  points.forEach(point => {\n    const dist = Math.hypot(point[0] - centerX, point[1] - centerY);\n    distances.push(dist);\n    totalDist += dist;\n  });\n  const avgDist = totalDist / points.length;\n\n  // Calculate variance in distances\n  let variance = 0;\n  distances.forEach(dist => {\n    variance += Math.pow(dist - avgDist, 2);\n  });\n  variance = variance / distances.length;\n\n  // Method 2: Expected vs actual circumference\n  const radius = Math.min(width, height) / 2;\n  const expectedCirc = 2 * Math.PI * radius;\n  const circRatio = pathLength / expectedCirc;\n\n  // Method 3: Aspect ratio (should be very close to 1 for circles)\n  const aspectRatio = Math.min(width, height) / Math.max(width, height);\n\n  // Method 4: Direction changes (circles should have many gradual changes)\n  let directionChanges = 0;\n  const directions = [];\n  for (let i = 1; i < points.length; i++) {\n    const dx = points[i][0] - points[i - 1][0];\n    const dy = points[i][1] - points[i - 1][1];\n    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\n      directions.push(Math.atan2(dy, dx));\n    }\n  }\n  for (let i = 1; i < directions.length; i++) {\n    const angleDiff = Math.abs(directions[i] - directions[i - 1]);\n    if (angleDiff > Math.PI / 12) directionChanges++;\n  }\n\n  // Circle should have many small direction changes, not few large ones\n  const directionScore = Math.min(directionChanges / 20, 1);\n\n  // Stricter scoring for circles\n  const varianceScore = 1 - Math.min(variance / (radius * radius * 0.5), 1); // More strict\n  const circScore = 1 - Math.abs(circRatio - 1);\n  const aspectScore = Math.pow(aspectRatio, 2); // Square to penalize non-circular shapes more\n\n  // More lenient requirements for circles/ovals\n  if (aspectRatio < 0.6) {\n    return 0; // Not circular enough (allows ovals)\n  }\n\n  // More lenient circumference ratio for ovals\n  if (Math.abs(circRatio - 1) > 0.5) {\n    return 0; // Circumference too far from expected\n  }\n  const finalScore = varianceScore * 0.4 + circScore * 0.3 + aspectScore * 0.2 + directionScore * 0.1;\n  console.log('Circle Detection:', {\n    varianceScore,\n    circScore,\n    aspectScore,\n    directionScore,\n    finalScore,\n    directionChanges,\n    aspectRatio,\n    circRatio\n  });\n  return finalScore;\n}\nfunction detectRectangle(points, width, height, pathLength) {\n  // Method 1: Direction changes (should be around 4 for rectangle)\n  let directionChanges = 0;\n  const directions = [];\n  for (let i = 1; i < points.length; i++) {\n    const dx = points[i][0] - points[i - 1][0];\n    const dy = points[i][1] - points[i - 1][1];\n    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\n      directions.push(Math.atan2(dy, dx));\n    }\n  }\n  for (let i = 1; i < directions.length; i++) {\n    const angleDiff = Math.abs(directions[i] - directions[i - 1]);\n    if (angleDiff > Math.PI / 6) directionChanges++;\n  }\n\n  // Method 2: Expected vs actual perimeter\n  const expectedPerim = 2 * (width + height);\n  const perimRatio = pathLength / expectedPerim;\n  const perimScore = 1 - Math.abs(perimRatio - 1);\n\n  // Method 3: Aspect ratio (rectangles can be any ratio, but not too extreme)\n  const aspectRatio = Math.min(width, height) / Math.max(width, height);\n\n  // Method 4: Straight line detection\n  let straightLines = 0;\n  for (let i = 2; i < points.length; i++) {\n    const p1 = points[i - 2];\n    const p2 = points[i - 1];\n    const p3 = points[i];\n    const angle1 = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);\n    const angle2 = Math.atan2(p3[1] - p2[1], p3[0] - p2[0]);\n    const angleDiff = Math.abs(angle1 - angle2);\n    if (angleDiff < Math.PI / 12) straightLines++;\n  }\n  const straightLineScore = Math.min(straightLines / points.length, 1);\n\n  // Method 5: Corner detection (should have 4 distinct corners)\n  const cornerScore = 1 - Math.abs(directionChanges - 4) / 4;\n\n  // Stricter requirements for rectangles\n  // Must have approximately 4 direction changes\n  if (directionChanges < 2 || directionChanges > 8) {\n    return 0; // Not rectangular enough\n  }\n\n  // More lenient perimeter ratio\n  if (Math.abs(perimRatio - 1) > 0.6) {\n    return 0; // Perimeter too far from expected\n  }\n\n  // More lenient straight line requirement\n  if (straightLineScore < 0.2) {\n    return 0; // Not enough straight lines\n  }\n\n  // Combine scores\n  const finalScore = cornerScore * 0.4 + perimScore * 0.3 + straightLineScore * 0.2 + aspectRatio * 0.1;\n  console.log('Rectangle Detection:', {\n    directionChanges,\n    cornerScore,\n    perimScore,\n    straightLineScore,\n    aspectRatio,\n    finalScore,\n    perimRatio\n  });\n  return finalScore;\n}\nfunction detectLine(points, width, height, pathLength) {\n  // Method 1: Straightness - check how straight the line is\n  let straightnessScore = 0;\n  let totalDeviation = 0;\n\n  // Calculate the overall direction of the line\n  const startPoint = points[0];\n  const endPoint = points[points.length - 1];\n  const overallDx = endPoint[0] - startPoint[0];\n  const overallDy = endPoint[1] - startPoint[1];\n  const overallLength = Math.hypot(overallDx, overallDy);\n  if (overallLength === 0) return 0;\n\n  // Calculate how much each point deviates from the straight line\n  for (let i = 1; i < points.length - 1; i++) {\n    const point = points[i];\n    const t = ((point[0] - startPoint[0]) * overallDx + (point[1] - startPoint[1]) * overallDy) / (overallLength * overallLength);\n    const projectedX = startPoint[0] + t * overallDx;\n    const projectedY = startPoint[1] + t * overallDy;\n    const deviation = Math.hypot(point[0] - projectedX, point[1] - projectedY);\n    totalDeviation += deviation;\n  }\n  const avgDeviation = totalDeviation / (points.length - 2);\n  const maxDeviation = Math.min(width, height) * 0.2; // Allow 20% deviation (increased from 10%)\n  straightnessScore = Math.max(0, 1 - avgDeviation / maxDeviation);\n\n  // Method 2: Direction consistency\n  let directionChanges = 0;\n  const directions = [];\n  for (let i = 1; i < points.length; i++) {\n    const dx = points[i][0] - points[i - 1][0];\n    const dy = points[i][1] - points[i - 1][1];\n    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\n      directions.push(Math.atan2(dy, dx));\n    }\n  }\n  for (let i = 1; i < directions.length; i++) {\n    const angleDiff = Math.abs(directions[i] - directions[i - 1]);\n    if (angleDiff > Math.PI / 12) directionChanges++;\n  }\n\n  // Lines should have very few direction changes\n  const directionScore = Math.max(0, 1 - directionChanges / 5); // Increased from 3\n\n  // Method 3: Path length vs straight line distance\n  const straightLineDistance = Math.hypot(endPoint[0] - startPoint[0], endPoint[1] - startPoint[1]);\n  const pathRatio = pathLength / straightLineDistance;\n  const pathScore = Math.max(0, 1 - Math.abs(pathRatio - 1));\n\n  // Method 4: Aspect ratio - lines should be long and thin\n  const aspectRatio = Math.max(width, height) / Math.min(width, height);\n  const aspectScore = Math.min(aspectRatio / 5, 1); // Prefer aspect ratios > 5\n\n  // Method 5: Closure - lines should not be closed\n  const startEndDist = Math.hypot(startPoint[0] - endPoint[0], startPoint[1] - endPoint[1]);\n  const closureScore = startEndDist > Math.min(width, height) * 0.3 ? 1 : 0;\n\n  // More lenient requirements for lines\n  // Must be reasonably straight\n  if (straightnessScore < 0.5) {\n    return 0;\n  }\n\n  // Must have few direction changes\n  if (directionChanges > 4) {\n    return 0;\n  }\n\n  // Must not be closed\n  if (closureScore === 0) {\n    return 0;\n  }\n\n  // More lenient aspect ratio for lines\n  if (aspectRatio < 1.5) {\n    return 0;\n  }\n\n  // Combine scores\n  const finalScore = straightnessScore * 0.4 + directionScore * 0.3 + pathScore * 0.2 + aspectScore * 0.1;\n  console.log('Line Detection:', {\n    straightnessScore,\n    directionScore,\n    pathScore,\n    aspectScore,\n    closureScore,\n    finalScore,\n    directionChanges,\n    aspectRatio,\n    pathRatio,\n    avgDeviation\n  });\n  return finalScore;\n}","map":{"version":3,"names":["SHAPES","recognizeShape","points","length","xs","map","p","ys","minX","Math","min","maxX","max","minY","maxY","width","height","centerX","centerY","pathLength","i","hypot","startEndDist","isClosedShape","lineScore","detectLine","circleScore","detectCircle","rectScore","detectRectangle","console","log","aspectRatio","thresholds","line","lineThreshold","circle","circleThreshold","rect","rectThreshold","margin","type","LINE","x","y","x2","y2","radius","CIRCLE","RECTANGLE","totalDist","distances","forEach","point","dist","push","avgDist","variance","pow","expectedCirc","PI","circRatio","directionChanges","directions","dx","dy","abs","atan2","angleDiff","directionScore","varianceScore","circScore","aspectScore","finalScore","expectedPerim","perimRatio","perimScore","straightLines","p1","p2","p3","angle1","angle2","straightLineScore","cornerScore","straightnessScore","totalDeviation","startPoint","endPoint","overallDx","overallDy","overallLength","t","projectedX","projectedY","deviation","avgDeviation","maxDeviation","straightLineDistance","pathRatio","pathScore","closureScore"],"sources":["C:/Users/Amoolya Suneja/Desktop/AI-Liveboard/client/src/utils/shapeRecognition.js"],"sourcesContent":["import { SHAPES } from './constants';\r\n\r\nexport function recognizeShape(points) {\r\n  if (!points || points.length < 6) return null;\r\n\r\n  // Calculate bounding box\r\n  const xs = points.map(p => p[0]);\r\n  const ys = points.map(p => p[1]);\r\n  const minX = Math.min(...xs);\r\n  const maxX = Math.max(...xs);\r\n  const minY = Math.min(...ys);\r\n  const maxY = Math.max(...ys);\r\n  const width = maxX - minX;\r\n  const height = maxY - minY;\r\n  const centerX = (minX + maxX) / 2;\r\n  const centerY = (minY + maxY) / 2;\r\n\r\n  // Skip very small shapes\r\n  if (width < 20 || height < 20) return null;\r\n\r\n  // Calculate path length\r\n  let pathLength = 0;\r\n  for (let i = 1; i < points.length; i++) {\r\n    pathLength += Math.hypot(\r\n      points[i][0] - points[i-1][0],\r\n      points[i][1] - points[i-1][1]\r\n    );\r\n  }\r\n\r\n  // Calculate shape closure\r\n  const startEndDist = Math.hypot(\r\n    points[0][0] - points[points.length-1][0],\r\n    points[0][1] - points[points.length-1][1]\r\n  );\r\n  const isClosedShape = startEndDist < Math.min(width, height) * 0.6;\r\n\r\n  // Multiple detection methods\r\n  const lineScore = detectLine(points, width, height, pathLength);\r\n  const circleScore = detectCircle(points, centerX, centerY, width, height, pathLength);\r\n  const rectScore = detectRectangle(points, width, height, pathLength);\r\n\r\n  console.log('Shape Analysis:', {\r\n    points: points.length,\r\n    width,\r\n    height,\r\n    aspectRatio: Math.min(width, height) / Math.max(width, height),\r\n    startEndDist,\r\n    isClosedShape,\r\n    lineScore,\r\n    circleScore,\r\n    rectScore,\r\n    thresholds: {\r\n      line: lineThreshold,\r\n      circle: circleThreshold,\r\n      rect: rectThreshold,\r\n      margin\r\n    }\r\n  });\r\n\r\n  // Improved decision logic with more lenient thresholds\r\n  const lineThreshold = 0.6;    // Lowered from 0.8\r\n  const circleThreshold = 0.5;  // Lowered from 0.7\r\n  const rectThreshold = 0.5;    // Lowered from 0.6\r\n  const margin = 0.1;           // Reduced from 0.2\r\n  \r\n  // Check for line first (highest priority)\r\n  if (lineScore > lineThreshold && lineScore > Math.max(circleScore, rectScore) + margin) {\r\n    return {\r\n      type: SHAPES.LINE,\r\n      x: minX,\r\n      y: minY,\r\n      x2: maxX,\r\n      y2: maxY,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n  \r\n  // Check for circle/oval\r\n  if (circleScore > circleThreshold && circleScore > rectScore + margin) {\r\n    const radius = Math.min(width, height) / 2;\r\n    return {\r\n      type: SHAPES.CIRCLE,\r\n      x: centerX - radius,\r\n      y: centerY - radius,\r\n      radius: radius\r\n    };\r\n  }\r\n  \r\n  // Check for rectangle/square\r\n  if (rectScore > rectThreshold && rectScore > circleScore + margin) {\r\n    return {\r\n      type: SHAPES.RECTANGLE,\r\n      x: minX,\r\n      y: minY,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction detectCircle(points, centerX, centerY, width, height, pathLength) {\r\n  // Method 1: Distance from center consistency\r\n  let totalDist = 0;\r\n  let distances = [];\r\n  \r\n  points.forEach(point => {\r\n    const dist = Math.hypot(point[0] - centerX, point[1] - centerY);\r\n    distances.push(dist);\r\n    totalDist += dist;\r\n  });\r\n  \r\n  const avgDist = totalDist / points.length;\r\n  \r\n  // Calculate variance in distances\r\n  let variance = 0;\r\n  distances.forEach(dist => {\r\n    variance += Math.pow(dist - avgDist, 2);\r\n  });\r\n  variance = variance / distances.length;\r\n  \r\n  // Method 2: Expected vs actual circumference\r\n  const radius = Math.min(width, height) / 2;\r\n  const expectedCirc = 2 * Math.PI * radius;\r\n  const circRatio = pathLength / expectedCirc;\r\n  \r\n  // Method 3: Aspect ratio (should be very close to 1 for circles)\r\n  const aspectRatio = Math.min(width, height) / Math.max(width, height);\r\n  \r\n  // Method 4: Direction changes (circles should have many gradual changes)\r\n  let directionChanges = 0;\r\n  const directions = [];\r\n  \r\n  for (let i = 1; i < points.length; i++) {\r\n    const dx = points[i][0] - points[i-1][0];\r\n    const dy = points[i][1] - points[i-1][1];\r\n    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\r\n      directions.push(Math.atan2(dy, dx));\r\n    }\r\n  }\r\n  \r\n  for (let i = 1; i < directions.length; i++) {\r\n    const angleDiff = Math.abs(directions[i] - directions[i-1]);\r\n    if (angleDiff > Math.PI/12) directionChanges++;\r\n  }\r\n  \r\n  // Circle should have many small direction changes, not few large ones\r\n  const directionScore = Math.min(directionChanges / 20, 1);\r\n  \r\n  // Stricter scoring for circles\r\n  const varianceScore = 1 - Math.min(variance / (radius * radius * 0.5), 1); // More strict\r\n  const circScore = 1 - Math.abs(circRatio - 1);\r\n  const aspectScore = Math.pow(aspectRatio, 2); // Square to penalize non-circular shapes more\r\n  \r\n  // More lenient requirements for circles/ovals\r\n  if (aspectRatio < 0.6) {\r\n    return 0; // Not circular enough (allows ovals)\r\n  }\r\n  \r\n  // More lenient circumference ratio for ovals\r\n  if (Math.abs(circRatio - 1) > 0.5) {\r\n    return 0; // Circumference too far from expected\r\n  }\r\n  \r\n  const finalScore = (varianceScore * 0.4 + circScore * 0.3 + aspectScore * 0.2 + directionScore * 0.1);\r\n  \r\n  console.log('Circle Detection:', {\r\n    varianceScore,\r\n    circScore,\r\n    aspectScore,\r\n    directionScore,\r\n    finalScore,\r\n    directionChanges,\r\n    aspectRatio,\r\n    circRatio\r\n  });\r\n  \r\n  return finalScore;\r\n}\r\n\r\nfunction detectRectangle(points, width, height, pathLength) {\r\n  // Method 1: Direction changes (should be around 4 for rectangle)\r\n  let directionChanges = 0;\r\n  const directions = [];\r\n  \r\n  for (let i = 1; i < points.length; i++) {\r\n    const dx = points[i][0] - points[i-1][0];\r\n    const dy = points[i][1] - points[i-1][1];\r\n    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\r\n      directions.push(Math.atan2(dy, dx));\r\n    }\r\n  }\r\n  \r\n  for (let i = 1; i < directions.length; i++) {\r\n    const angleDiff = Math.abs(directions[i] - directions[i-1]);\r\n    if (angleDiff > Math.PI/6) directionChanges++;\r\n  }\r\n  \r\n  // Method 2: Expected vs actual perimeter\r\n  const expectedPerim = 2 * (width + height);\r\n  const perimRatio = pathLength / expectedPerim;\r\n  const perimScore = 1 - Math.abs(perimRatio - 1);\r\n  \r\n  // Method 3: Aspect ratio (rectangles can be any ratio, but not too extreme)\r\n  const aspectRatio = Math.min(width, height) / Math.max(width, height);\r\n  \r\n  // Method 4: Straight line detection\r\n  let straightLines = 0;\r\n  for (let i = 2; i < points.length; i++) {\r\n    const p1 = points[i-2];\r\n    const p2 = points[i-1];\r\n    const p3 = points[i];\r\n    \r\n    const angle1 = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);\r\n    const angle2 = Math.atan2(p3[1] - p2[1], p3[0] - p2[0]);\r\n    const angleDiff = Math.abs(angle1 - angle2);\r\n    \r\n    if (angleDiff < Math.PI/12) straightLines++;\r\n  }\r\n  \r\n  const straightLineScore = Math.min(straightLines / points.length, 1);\r\n  \r\n  // Method 5: Corner detection (should have 4 distinct corners)\r\n  const cornerScore = 1 - Math.abs(directionChanges - 4) / 4;\r\n  \r\n  // Stricter requirements for rectangles\r\n  // Must have approximately 4 direction changes\r\n  if (directionChanges < 2 || directionChanges > 8) {\r\n    return 0; // Not rectangular enough\r\n  }\r\n  \r\n  // More lenient perimeter ratio\r\n  if (Math.abs(perimRatio - 1) > 0.6) {\r\n    return 0; // Perimeter too far from expected\r\n  }\r\n  \r\n  // More lenient straight line requirement\r\n  if (straightLineScore < 0.2) {\r\n    return 0; // Not enough straight lines\r\n  }\r\n  \r\n  // Combine scores\r\n  const finalScore = (\r\n    cornerScore * 0.4 + \r\n    perimScore * 0.3 + \r\n    straightLineScore * 0.2 + \r\n    aspectRatio * 0.1\r\n  );\r\n  \r\n  console.log('Rectangle Detection:', {\r\n    directionChanges,\r\n    cornerScore,\r\n    perimScore,\r\n    straightLineScore,\r\n    aspectRatio,\r\n    finalScore,\r\n    perimRatio\r\n  });\r\n  \r\n  return finalScore;\r\n}\r\n\r\nfunction detectLine(points, width, height, pathLength) {\r\n  // Method 1: Straightness - check how straight the line is\r\n  let straightnessScore = 0;\r\n  let totalDeviation = 0;\r\n  \r\n  // Calculate the overall direction of the line\r\n  const startPoint = points[0];\r\n  const endPoint = points[points.length - 1];\r\n  const overallDx = endPoint[0] - startPoint[0];\r\n  const overallDy = endPoint[1] - startPoint[1];\r\n  const overallLength = Math.hypot(overallDx, overallDy);\r\n  \r\n  if (overallLength === 0) return 0;\r\n  \r\n  // Calculate how much each point deviates from the straight line\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const point = points[i];\r\n    const t = ((point[0] - startPoint[0]) * overallDx + (point[1] - startPoint[1]) * overallDy) / (overallLength * overallLength);\r\n    const projectedX = startPoint[0] + t * overallDx;\r\n    const projectedY = startPoint[1] + t * overallDy;\r\n    const deviation = Math.hypot(point[0] - projectedX, point[1] - projectedY);\r\n    totalDeviation += deviation;\r\n  }\r\n  \r\n  const avgDeviation = totalDeviation / (points.length - 2);\r\n  const maxDeviation = Math.min(width, height) * 0.2; // Allow 20% deviation (increased from 10%)\r\n  straightnessScore = Math.max(0, 1 - (avgDeviation / maxDeviation));\r\n  \r\n  // Method 2: Direction consistency\r\n  let directionChanges = 0;\r\n  const directions = [];\r\n  \r\n  for (let i = 1; i < points.length; i++) {\r\n    const dx = points[i][0] - points[i-1][0];\r\n    const dy = points[i][1] - points[i-1][1];\r\n    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\r\n      directions.push(Math.atan2(dy, dx));\r\n    }\r\n  }\r\n  \r\n  for (let i = 1; i < directions.length; i++) {\r\n    const angleDiff = Math.abs(directions[i] - directions[i-1]);\r\n    if (angleDiff > Math.PI/12) directionChanges++;\r\n  }\r\n  \r\n  // Lines should have very few direction changes\r\n  const directionScore = Math.max(0, 1 - (directionChanges / 5)); // Increased from 3\r\n  \r\n  // Method 3: Path length vs straight line distance\r\n  const straightLineDistance = Math.hypot(endPoint[0] - startPoint[0], endPoint[1] - startPoint[1]);\r\n  const pathRatio = pathLength / straightLineDistance;\r\n  const pathScore = Math.max(0, 1 - Math.abs(pathRatio - 1));\r\n  \r\n  // Method 4: Aspect ratio - lines should be long and thin\r\n  const aspectRatio = Math.max(width, height) / Math.min(width, height);\r\n  const aspectScore = Math.min(aspectRatio / 5, 1); // Prefer aspect ratios > 5\r\n  \r\n  // Method 5: Closure - lines should not be closed\r\n  const startEndDist = Math.hypot(startPoint[0] - endPoint[0], startPoint[1] - endPoint[1]);\r\n  const closureScore = startEndDist > Math.min(width, height) * 0.3 ? 1 : 0;\r\n  \r\n  // More lenient requirements for lines\r\n  // Must be reasonably straight\r\n  if (straightnessScore < 0.5) {\r\n    return 0;\r\n  }\r\n  \r\n  // Must have few direction changes\r\n  if (directionChanges > 4) {\r\n    return 0;\r\n  }\r\n  \r\n  // Must not be closed\r\n  if (closureScore === 0) {\r\n    return 0;\r\n  }\r\n  \r\n  // More lenient aspect ratio for lines\r\n  if (aspectRatio < 1.5) {\r\n    return 0;\r\n  }\r\n  \r\n  // Combine scores\r\n  const finalScore = (\r\n    straightnessScore * 0.4 +\r\n    directionScore * 0.3 +\r\n    pathScore * 0.2 +\r\n    aspectScore * 0.1\r\n  );\r\n  \r\n  console.log('Line Detection:', {\r\n    straightnessScore,\r\n    directionScore,\r\n    pathScore,\r\n    aspectScore,\r\n    closureScore,\r\n    finalScore,\r\n    directionChanges,\r\n    aspectRatio,\r\n    pathRatio,\r\n    avgDeviation\r\n  });\r\n  \r\n  return finalScore;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}